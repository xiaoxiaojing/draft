1.  object categories

- Ordinary objects
- Exotic objects
- Standard objects
- Built-in objects

2.  Object literal syntax Extensions

- 简洁的属性初始化（Property Initializer Shorthand）

```
function createPerson (name, age) {
  return {
    name,
    age
  }
}
```

- 简洁的方法声明（Concise Methods）

```
var person = {
  name: 'xxj',
  sayName () {
    console.log(this.name)
  }
}
```

- Computed Property Names

```
var suffix = " name";
var person = {
    ["first" + suffix]: "Nicholas",
    ["last" + suffix]: "Zakas"
};
console.log(person["first name"]); // "Nicholas"
console.log(person["last name"]); // "Zakas"
```

3.  New Methods

- `Object.is()`：用于比较两个值相等（当且仅当类型和值相等时，两个值才相等）
  - `Object.is()`和`===`的比较结果一致，除了`-0 和 0`、`NaN 和 NaN`

```
+0 === -0 // true
Object.is(+0, -0) // false

NaN === NaN // false
Object.is(NaN, NaN) // true

Object.is(5, "5") // false
```

- `Object.assign()`
  - `supplier`的访问器属性会变成`receiver`的数据属性

```
var receiver = {},
  supplier = {
    get name() {
      return "file.js"
    }
  };
Object.assign(receiver, supplier);
var descriptor = Object.getOwnPropertyDescriptor(receiver, "name");
console.log(descriptor.value);      // "file.js"
console.log(descriptor.get);        // undefined
```

4.  重复的属性声明

- 在 ES5 的严格模式下，重复的属性声明会报错。ES6 不会，属性的值是最后一个同名属性的值。

```
"use strict";
var person = {
  name: "Nicholas",
  name: "Greg"        // no error in ES6 strict mode
};
console.log(person.name);       // "Greg"
```

5.  属性枚举顺序（Property Enumeration Order）

- 枚举顺序会影响到一些方法的返回值和执行过程

  - Object.getOwnPropertyNames()：返回值按照枚举顺序排序
  - Reflect.ownKeys：返回值按照枚举顺序排序
  - Object.assign()：枚举顺序会影响属性合并的执行顺序

- 枚举顺序
  - 先枚举`numeric keys`，且所有`numeric keys`按照升序排列
  - 再枚举`string keys`，且所有`string keys`按照添加到对象中的顺序排序
  - 最后枚举`symbol keys`，且所有`symbol keys`按照添加到对象中的顺序排序

> 注：由于不同 JavaScript 引擎对`for-in loop`的实现不一样，所以`for-in, Object.keys(), JSON.stringify()`属性枚举顺序依然不确定

6.  操作 Prototypes

- 获取：`Object.getPrototypeOf()`
- 修改：`Object.setPrototypeOf(originObject, changeObject)`，实际上修改的是`[[Prototype]]`的值
- 通过`super`获取当前对象的 prototype：`super.func()`等价于`Object.getPrototypeOf(this).func.call(this)`
